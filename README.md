# Conway-s-Game-of-Life


### A small implementation of [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) implementation in C . 

### In the course of data structures we called to implement Conway's Game of Life 
#### The professor gave us a completed data-structure library with many ADTs and i chose ADTSet that is implemented with AVL Tree to complete the project

Notice : Code comments are in Greek Language . **
Soon I will update README and the whole repo with english comments and README

* [Greek Version](#Greek-Version)
* [English Version](#English-Version)

## Greek Version:

#### Γενικές πληροφορίες για την Άσκηση:
Αρχικά , στην υλοποίηση μου έχω ορίσει το **LifeState** να αναπαρίσταται από **ATDSet**  , με τη χρήση της εντολής `typedef Set LifeState` . Στο **Set** αυτό κρατάω τα κελιά , τα οποία είναι ζωντανά και μόνο αυτά. Οποιοδήποτε κελί **ΔΕΝ** βρίσκεται μέα στο **Set** , θεωρείται νεκρό.
Μία λεπτομέρεια.Για λόγους καλαισθησίας , έχω έχω ορίσει τις συνεταγμένες **x,y** να αρχίζουν απο το **1** . Αυτό γιατί , ήθελα το σχήμα μιας κατάστασης , σε καρτεσιανό σύστημα συντεταγμένων να μην ακουμπάει τους άξονες. Επιπροσθέτως, εωρώ οτι για οποιδήποτε κελί ΔΕΝ έχω πληροφορία , το γεγονός ότι είναι νεκρο.
Επομένως το **glider** μπορει να γραφεί και ως **$bob$2bo$3o** εφόσον δεν έχω πληροφορία για το **(3,3)** και επομένως το θεωρώ **νεκρό** .

#### Σχετικά με το αρχείο `life.c` : 
*Το αρχείο αυτό θα το βρείτε στο directory  : modules/*

Στο σώμα του πέρα από τις απαραίτητες συναρτήσεις που ζητούνται από την εκφώνηση έχω υλοποιήσει κάποιες απλές συναρτήσεις οι οποίες με βοηθουν σε κάποια κομμάτια της υλοποίσης . Πληροφορίες σχετικά με την λειτουργία αυτών θα βρείτε στο αρχείο `life.h`.

##### Σετικά με την `life_create` :
Σε αυτή τη συνάρτηση καλέιται ο "δημιουργός" του ADT που επέλεξα( `set_create` ).Τίποτα παραπάνω.

##### Σετικά με την `life_create_from_rle` :
Σε αυτή τη συνάρτηση , ουσιαστικά διαβάζεται το αρχείο `rle` , που δίνεται ως όρισμα χαρακτήρα προς χαρακτήρα.Αρχικά ορίζω τα **x,y** στην τιμή **1** όπως ανέφερα παραπάνω.Χρησιμοποιώ μια `while` για να skipάρει τα `\n` τα οποία μπορεί σε πολλά αρχεία να συναντούμε . Επίσης έχω μια μεταβλητή , *multiplier*  η οποία αντιπροσωπεύει τον αριθμό που έχει διαβαστεί και αν έχει διαβαστεί αριθμός και ουσιαστικά χτίζεται διαβάζοντας ψηφιο προς ψηφίο . Έπειτα όταν σταμτήσει να διαβάζει ψηφία και έχει χτιστεί το τελικό *multiplier* , αν ο επόμενος χαρακτήρας είναι `o` **βάζει** τόσα κύτταρα στο **Set** κάθε φορά με συντεταγμένες αυξανόμενες ανά **x**.Αν ο επόμενος χαρακτήρας είναι `b` δεν το βάζει καθόλου μόνο αυξάνει το **x**. To **y** αλλάζει όταν βρεθεί χαρακτήρας `$`.Κάθε φορά που αυξάνεται το **y** , ελέγχουμε αν το **x** είναι μεγαλύτερο από το **μέγιστο x** και αντικαθιστούμε τη τιμή του **μέγιστου x** . Αυτό το κάνουμε για να ξέρουμε μέχρι πόσο φτάνει ο **άξονας x** , ώστε όταν διαβάσουμε σε μια γραμμή 7 ζωντανά και το μέγιστο είναι 7 , να γεμίσει 7 θέσεις αλλά άν διαβάσει μόνο 1 ζωντανό και απευθείας αλλαγή γραμμής , να βάλει τα υπόλοιπα 6 κύτταρα νεκρα.Τέλος έχει δημιουργήσει τη κατάσταση και την επιστρέφει.

##### Σετικά με την `life_save_to_rle` :
Σε αυτή τη συνάρτηση ,  ξεκινάμε **ψάχνοντας 1-1** τα σημεία με συντεταγμένες **x,y** , οι οποίες ορίζονται απ την `for` . Άν βρεθεί το σημείο (άρα είναι **ζωντανό** ) στην κατάσταση ( γραμμή κώδικα `if(life_get_cell(state,tempCell))` ) τότε προσθέτει σε μια βοηθητική συμβολοσειρά που έχω ορίσει εγώ , τον χαρακτήρα `o` . Αν δεν βρεθεί το σημείο (άρα είναι **νεκρό** ) στη κατάσταση , τότε στην συμβολοσειρά αυτή προσθέτει το  `b`. Επίσης όταν αλλάζει το **y** , προσθέτω τον χαρακτήρα `$` .Όταν τελειώσει με όλες τις `for` προσθέτει τον χαρακτήρα τέλους `!` . Στη συνέχεια εφόσον έχω φτιάξει αυτή τη πρόχειρη συμβολοσειρά , τη διατρέχω και ψάχνω να βρω ποιοι χαρακτήρες υπάρχουν πάνω από μία φορά ώστε να μπει ως πρόθεμα κάποιος αριθμός και να μην επαναλαμβάνονται οι ιδιοι χαρακτήρες στη σειρά. Προσθέτω στην τελική μου συμβολοσειρά , τον αριθμό (αν είναι μεγαλύτερος από 1) ακολουθούμενο από τον χαρακτήρα που επαναλαμβάνεται,διαφορετικά προσθέτω τον χαρακτήρα όπως είναι.Τέλος εκτυπώνω μήνυμα με την συμβολοσειρά που παράχθηκε (για λόγους σιγουριάς).

##### Σετικά με την `life_get_cell` :
Σε αυτή τη συνάρτηση , απλά ελέγχω αν υπάρχει το κύτταρο που βρίσκεται ως όρισμα, μέσα στο **Set**.

##### Σετικά με την `life_set_cell` :
Σε αυτή τη συνάρτηση , αλλάζω την κατάσταση του κελιού που βρίσκεται ως όρισμα.Αν θέλει να *ζωντανέψω* το **κελί** , το προσθέτω στο `LifeState` . Αν θέλει να το σκοτώσω , τότε **άν υπάρχει** στο `LifeState` το αφαιρώ.

##### Σετικά με την `life_evovle` :
Σε αυτή τη συνάρτηση ξεκινάμε **ψάχνοντας 1-1** τα σημεία με συντεταγμένες **x,y** , οι οποίες ορίζονται απ την `for`  και για κάθε ένα σημείο από αυτά βρίσκουμε πόσους **ζωντανούς γείτονες** έχει με την χρήση της συνάρτησης `get_neighbours_num` που εχει οριστεί στο ίδιο αρχείο και βρίσκει πόσους ζωντανούς γείτονες έχει κάθε κελί.Κάνει τους ελέγχους όπως ορίζονται απ την εκφώνση :  
> * Κάθε ζωντανό κελί με λιγότερους από 2 ή περισσότερους από 3 ζωντανούς γείτονες πεθαίνει (λόγω υπο- και υπερ-πληθυσμού αντίστοιχα).  
> * Κάθε νεκρό κελί με ακριβώς 3 ζωντανούς γείτονες ζωντανεύει (λόγω αναπαραγωγής).  
> * Ολα τα υπόλοιπα κελιά (ζωντανά ή νεκρά) παραμένουν ως έχουν.  
και στη συνέχεια εκτυπώνει το μέγεθος της νέας κατάστασης, δηλαδή της εξελιγμένης κατάστασης και την επιστρέφει.  

##### Σετικά με την `life_destroy` :
Σε αυτή τη συνάρτηση καλέιται ο "καταστροφέας" του ADT που επέλεξα( `set_destroy` ).Τίποτα παραπάνω.


## English Version:

... **Soon** ...
